---
title: "Synoptic CB: Porewater DIC"
author: "June 2023 Samples"
date: "`r Sys.Date()`"
output: 
  pdf_document:
    toc: true
    number_sections: true
output_dir: "To Be Reviewed/PDF"
---
\newpage

##Setup - Change things here & write any notes
```{r setup info}

#identify section 
cat("Setup Information")


###### Run information - PLEASE CHANGE
  Date_Run = "MM/DD/YY"  #Date that instrument was run
  Run_by = "Stephanie J. Wilson"  #Instrument user 
  Script_run_by = "Stephanie J. Wilson" #Code user 
  run_notes = " The standard curve was checked manually on the instrument for this run. "  #any notes from the run
  samples <- c("GCW", "GWI", "MSM", "SWH") #whatever identifies your samples within the same names 
  samples_pattern <- paste(samples, collapse = "|") 
    #samples_pattern <- "GCW" #use this instead of the line above if you have only one site code 
  chks_name = "Chk_Std_"  #what did you name your check standards? 
  crm_name = "CRM|crm"    #what did you name your CRMS? 
  
###### File Names - PLEASE CHANGE 
#file path and name for raw summary data file 
    raw_file_name = "Raw Data/TOCTN_COMPASS_Synoptic_DIC_202306.txt" 
    
#file path and name for raw all peaks file 
    #raw_allpeaks_name = "Raw Data/TOCTN_COMPASS_Synoptic_DIC_202305_allpeaks.txt"

#file path and name of processed data file 
    processed_file_name = "Processed Data/COMPASS_SynopticCB_PW_Processed_DIC_202306.csv"


###### Log Files - PLEASE CHECK 
#downloaded metadata csv - downloaded from Google drive as csv for this year
  Raw_Metadata = "Raw Data/COMPASS_SynopticCB_PW_SampleLog_2023.csv"
  
#qaqc log file path for this year 
 # Log_path = "Raw Data/COMPASS_Synoptic_DIC_QAQClog_2023.csv"
```

##Set Up Code
```{r setup, include=FALSE}

#identify section 
cat("Setup")

#Link to the protocol used for analysis 
  #steph will add this soon 

#Packages that are required 
lapply(c(
  "dplyr", "ggplot2", "ggpubr", "stringr",
  "purrr", "tidyverse", "here", "broom",
  "googledrive", "googlesheets4"), 
  library, character.only = TRUE)

#any coefficients / constants that are needed for calculations 
  mw_c <- 12.011   #molecular weight of Carbon 
  mw_n <- 14.0067  #molecular weight of Nitrogen
  Con1 <- 1000       # conversion factor value
  Con2 <- 1000000    # conversion factor value 

#Flag that we 
  r2_cutoff = 0.98  #this is the level below which we want to rerun or consider a curve 
  chk_flag = 0.10   #for the RSD (relative standard deviation) 
  chk_conc_flag = 15 #this is the level cutoff for percent difference of check standards vs. the concentration they are meant to be 
  chks_flag = 50 #this is the percent of chks we want to have a CV less than 10, usually 60
  rep_flag = 25 #this is a 25% error between samples
  #blank_flag - calculated based on samples later in this code as lower 25% quantile of sample concentrations

#critical reference material concentration - Update if running different checks: ** needs update 
   ic_crm = 22.19
   
#Top standard Concentrations- Update if running different standard curve: 
   top_std_c = 200

#Set time zone 
  common_tz = "Etc/GMT+5"
  Sys.setenv(TZ = "America/New_York")
  
#plot indicators 
  site_order <- c('GCW', 'MSM', 'GWI', 'SWH')
  plot_order <- c('UP', 'SWAMP', 'TR', 'WC', 'SW')
  plot_colors <- c("#20063B", "darkgrey", "#FFBC42", "#419973", "#25ABE6" )


```

##Read in metadata and create similar sample IDs for matching to samples 
```{r pull in metadata for later, include=FALSE}

#read in the raw metadata file 
raw_metadata <- read.csv(Raw_Metadata)

#make a new columns in the metadata with important info:
metadata <- raw_metadata %>%
  mutate(Depth = paste0(Depth_cm, "cm")) %>%
  mutate(LysID = paste0("Lys", Lysimeter)) %>%
  mutate(YearMonth = sprintf("%d%02d", Year, Month))  %>%
  mutate(Zone = case_when(
    `Transect.Location` == "Transition" ~ "TR",
    `Transect.Location` == "Wetland"    ~ "WC",
    `Transect.Location` == "Upland"     ~ "UP", 
    `Transect.Location` == "Surface Water" ~ "SW",
    TRUE                 ~ `Transect.Location`    # keep original value if no match
  )) %>%
  rename('DIC' = DIC......if..50mL.)

#Create DOC IDs from what was collected for comparison later
metadata <- metadata %>%
  mutate(DIC_ID = ifelse(DIC == "x",
                          paste(Site,
                                YearMonth, 
                                Zone,
                                LysID,
                                Depth,
                                sep = "_"),
                          NA) )

#Change the SW lines because they don't have lysimeters or a depth  
metadata <- metadata %>%
  mutate(
    DIC_ID = if_else(
      Zone == "SW",
      # Modify the string:
      DIC_ID %>%
        str_replace("_LysA", "_A") %>%                    # Replace "_LysA" with "_A"
        str_replace("_LysB", "_B") %>%                    # Replace "_LysB" with "_B"
        str_replace("_LysC", "_C") %>%                    # Replace "_LysC" with "_C"
        str_replace("_0cm$", ""),                          # Remove trailing "_0cm"
      DIC_ID  # else keep original
    )
  )

#Take out the columns and rows that are not relevant
dic_metadata <- metadata %>%
  select(DIC_ID, Year, Month, Day, YearMonth, Site, Zone, Lysimeter, LysID, Depth_cm, 
         Depth, Time..24hr., Time.Zone_EDT.EST, Field.Notes, ) %>%        
  # only keep specific columns
  filter(!is.na(DIC_ID) & DIC_ID != "")  # remove missing/blank DIC_ID rows

#head(doc_metadata)

```

## Import Data Functions  
```{r create function to read in data, include=FALSE}

## Create a function to read in data from summary file: 
read_data <- function(data){
  # Second, read in data
  read_delim(file = data, skip = 10, delim = "\t", show_col_types = FALSE) %>% 
    rename(sample_name = `Sample Name`, 
           ic_raw = `Result(IC)`, 
          # tdn_raw = `Result(TN)`,
           run_datetime = `Date / Time`) %>% 
    select(sample_name, ic_raw,run_datetime)
}

## Create a function to read in data from all peaks file:
read_curve <- function(data){
  # Second, read in data
  read_delim(file = data, skip = 10, delim = "\t", show_col_types = FALSE) %>% 
    rename(sample_name = `Sample Name`,
           analyte = `Analysis(Inj.)`,
           concentration = `Conc.`,
           area = Area,
           manual_dilution = `Manual Dilution`,
           excluded = Excluded,
           run_datetime = `Date / Time`) %>% 
    filter(excluded == 0) %>% #filter to injections that are included in the analysis 
    select(sample_name, analyte, concentration, area, run_datetime) %>%
    pivot_wider(names_from= analyte, values_from = concentration) %>%
    rename(dic_raw = IC)
}
```

## Import Sample Data     
```{r Import Data, echo=FALSE}

cat("Import Sample Data")

#Pull in data that from the raw data file based on the sample info input above 
dat_raw <- raw_file_name %>%
  map_df(read_data) %>%
  filter(str_detect(sample_name, samples_pattern))

#Looks like one sample was run twice and we should remove it: 
dat_raw <- dat_raw %>%
  filter(!(sample_name == "GWI_202306_SW_A" & ic_raw == 9.863))

head(dat_raw)
```

## Assessing Standard Curves - assessed on the instrument manually 

## CRM Check - no CRMs included on this run 

## Assess Check Standards 
```{r Check Standards, echo=FALSE}

cat("Assess the Check Standards")

#Pull out check standards from raw file 
chks_raw <- raw_file_name %>% 
  map_df(read_data) %>% 
  filter(grepl(chks_name, sample_name)) %>% # filter to TMP samples only
  bind_rows() 

#we don't always the same checks so we need to pull the concentration out of the name 
chks_raw <- chks_raw %>%
  mutate(chk_std_conc = str_extract(sample_name, "\\d+")) %>%  # extract the number
  mutate(chk_std_conc = as.numeric(chk_std_conc))    # convert to numeric

chks_raw <- chks_raw %>% 
  mutate(rep = row_number())

#no rsv calculated for DIC because they are all different concentrations

#calculate percent difference between check standards & expected concentration 
chks_raw$C_diff <- ((chks_raw$ic_raw - chks_raw$chk_std_conc)/((chks_raw$ic_raw + chks_raw$chk_std_conc)/2)) * 100
chks_raw$C_diff_flag <-  ifelse(abs(chks_raw$C_diff) <= chk_conc_flag, 'YES', 'NO, rerun')

#Plot the check standardsvs. the expected concentration 
c_chks <-  ggplot(data = chks_raw, aes(x = rep, y = ic_raw, fill=C_diff_flag)) +
       geom_bar(stat = 'identity') + 
        scale_fill_manual(values = c("YES" = "darkgreen", "NO, rerun" = "darkgrey")) +
        theme_classic() + labs(x= " ", y="IC (mg/L)", title="Check Stds: IC") + 
        theme(legend.position="bottom")  + 
              guides(fill=guide_legend(title="% Difference <10%"))

c_chks

#calculate the percent of check standards that are within the range based on the flag 
c_chks_percent <- (sum(chks_raw$C_diff_flag == "YES")/nrow(chks_raw))*100

#report out if flags indicate need for rerun
ifelse(c_chks_percent >= chk_flag, ">60% of IC Check Standards are within range of expected concentration",
       "<60% of IC Check Standards are within range of expected concentration - REASSESS")

#write out a flag to the sample dataframe if less than 60% of the checks are within the expected CV
dat_raw$ic_flag <- ""

if (c_chks_percent <= chks_flag) {
  dat_raw$ic_flag <- ifelse(
    dat_raw$ic_flag != "",
    paste0(dat_raw$ic_flag, "; IC checks out of range"),
    "IC checks out of range"
  )
}


```

## Assess Blanks 
```{r Check Blanks, echo=FALSE}

cat("Assess Blanks")

#Pull out the blanks from raw file 
blks_raw <- raw_file_name %>% 
  map_df(read_data) %>% 
  filter(grepl("DI", sample_name)) %>% # filter to TMP samples only
  bind_rows() 

blks_raw <- blks_raw %>% 
  mutate(rep = row_number())  %>%
  filter(!ic_raw < 0.001) #remove DIs that weren't actually run and are completely zero 

#Check if the blanks are above the lower 25% quantile of your data 
blk_flag_c <- quantile(dat_raw$ic_raw, prob=c(.25))   #this gives you the lower 25% quantile of the data 
blks_raw$C_diff_flag <-  ifelse(blks_raw$ic_raw <= blk_flag_c, 'YES', 'NO, rerun')

#calculate the percent of check standards that are within the range based on the flag 
c_blks_percent <- (sum(blks_raw$C_diff_flag == "YES")/nrow(blks_raw))*100

#report out if flags indicate need for rerun
ifelse(c_blks_percent >= chks_flag, ">60% of Carbon Blank concentrations are lower 25% quartile of samples",
       "<60% of Carbon blaks are lower 25% quartile of samples - REASSESS")

#Plot the blanks vs. the lower 25% quantile of your data in this run (black line)
c_blks <-  ggplot(data = blks_raw, aes(x = rep, y = ic_raw, fill=C_diff_flag)) +
       geom_bar(stat = 'identity') + 
        scale_fill_manual(values = c("YES" = "darkblue", "NO, rerun" = "darkgrey")) +
        theme_classic() + labs(x= " ", y="IC  (mg/L)", title="Blanks: IC") + 
        theme(legend.position="bottom") +  geom_hline(yintercept=blk_flag_c, linetype="dashed", 
                color = "black", linewidth=1)  + 
                guides(fill=guide_legend(title="Blank Conc <25% Quartile Samples"))

c_blks

#print out the average blank concentrations 
blk_avg_c <- mean(blks_raw$ic_raw)
cat("carbon blanks:")
print(blk_avg_c)

#write out a flag to the sample dataframe if more than 60% of the blanks are above the lower 25% quantile of samples
if (c_blks_percent <= chks_flag) {
  dat_raw$ic_flag <- ifelse(
    dat_raw$ic_flag != "",
    paste0(dat_raw$ic_flag, "; IC blanks out of range"),
    "IC blanks out of range"
  )
}

```

## Assess Duplicates 
```{r Check Duplicates, echo=FALSE}

cat("Assess Duplicates")

#Take a look at the raw data 
  #head(dat_raw)

#pull out any rows that have "dup" in the sample_name column
dups <- dat_raw %>%  
  select(!c(ic_flag)) %>%
  filter(str_detect(sample_name, "dup"))      #have to change this to match data

#create a new dataframe and remove dups from sample dataframe 
dat_raw2 <- dat_raw %>%  
  filter(!str_detect(sample_name, "dup")) 

#remove the dup from these IDs so we will have duplicate sample names
dups$sample_name<-gsub("_dup","",as.character(dups$sample_name))
dups <- dups[ ,-c(3)] #remove the run date time for 
colnames(dups) <- c('sample_name', 'ic_raw_dup')

#merge with the dataframe so we have a column for the conc and the dup
QAdups <- merge(dat_raw2, dups)

#create a dataframe to compare npoc dups 
df2 <- as.data.frame(QAdups$ic_raw)
df2$dups <- QAdups$ic_raw_dup

#calculate the cv of the duplicates
df2$sds <- apply(df2,1,sd)
df2$mean <- apply(df2, 1, mean)

QAdups$ic_dups_cv <- (df2$sds/df2$mean) * 100
QAdups$ic_dups_cv_flag <-  ifelse(QAdups$ic_dups_cv <10, 'YES', 'NO, rerun')

#Put all the dups together and create row numbers for plotting
QAdups <- QAdups %>%
  mutate(row_num = row_number())
#head(QAdups)

#plot dups output as a bar graph to easily check - want any over 10% to be red need to work on this 
C_dups <- ggplot(data =QAdups, aes(x =row_num, y =ic_dups_cv, fill=ic_dups_cv_flag)) +
       geom_bar(stat = 'identity') + 
        theme_classic() + labs(x= " ", y="CV of IC Duplicates") + 
        scale_fill_manual(values = c("YES" = "darkgreen", "NO, rerun" = "red")) +
        theme(legend.position="none") +  geom_hline(yintercept=10, linetype="dashed", 
                color = "black", linewidth=1)  + 
              guides(fill=guide_legend(title="CV Between Dups <10%"))

C_dups

#calculate the percent of check standards that are within the range based on the flag 
c_dups_percent <- (sum(QAdups$ic_dups_cv_flag == "YES")/nrow(QAdups))*100

#report out if the dups are within range
ifelse(c_dups_percent >= chks_flag, ">60% of Carbon Duplicates have a CV <10%",
       "<60% of Carbon Duplicates have a CV <10% - REASSESS")

#write out a flag to the sample dataframe if more than 60% of the dups have CVs out of range 
if (c_dups_percent <= chks_flag) {
  dat_raw$ic_flag <- ifelse(
    dat_raw$ic_flag != "",
    paste0(dat_raw$ic_flag, "; IC dups out of range"),
    "IC dups out of range"
  )
}


```

## Sample Flagging - Are samples Within the range of the curve?  
```{r Sample Flagging, echo=FALSE}

cat("Sample Flagging")

#Flagging data if the concentration is outside the standards range and based on blanks
dat_flagged <- dat_raw %>%
  mutate(
    ic_flag = if_else(
      ic_raw > top_std_c,
      if_else(
        ic_flag != "" & !is.na(ic_flag),
        paste0(ic_flag, "; value above cal curve"),
        "value above cal curve"
      ),
      ic_flag
    ),
    ic_flag = if_else(
      blk_avg_c > 0.25 * ic_raw,
      if_else(
        ic_flag != "" & !is.na(ic_flag),
        paste0(ic_flag, "; blank is ≥ 25% of sample value"),
        "blank is ≥ 25% of sample value"
      ),
      ic_flag
    )
  )

#lets make a dataframe with just the concentration flag for plotting 
dat_flag_viz <- dat_raw %>% 
  mutate(ic_flag = case_when(ic_raw > top_std_c ~ "value above cal curve",
            blk_avg_c > 0.25*ic_raw ~ "blank is ≥ 25% of sample value")
 )

#Plot data and change colors based on flags to check it: 
c_samples_flag <-  ggplot(data = dat_flag_viz, aes(x = sample_name, y = ic_raw, fill=ic_flag)) +
       geom_bar(stat = 'identity') + 
        scale_fill_manual(values=c("red", "orange"))+
        theme_classic() + labs(x= " ", y="IC (mg/L)", title="C: Grey = Within Range of Curve") + 
        theme(legend.position="bottom")  + 
        theme(axis.text.x = element_text(angle = 90, hjust = 0.5))

c_samples_flag


```

## Visualize Data by Plot   
```{r Visualize Data, echo=FALSE}

cat("Visualize Data")

#Plot samples to get a first look at concentrations (sanity check)
IDs <- data.frame(do.call('rbind', strsplit(as.character(dat_flagged$sample_name),'_',fixed=TRUE)))
colnames(IDs) <- c( "Site_Code","Date" ,"Zone", "Lysimeter", "Depth", "Excess_Info")
#head(IDs)

#rejoin them to the dataframe
dat_flagged_id <- cbind(IDs, dat_flagged)

#Order by Zone from Upland to Surface Water
dat_flagged_id$Zone = factor(dat_flagged_id$Zone, levels = c( "UPCON","UP",  "TR", "WC", "SW"))
dat_flagged_id <- dat_flagged_id[order(dat_flagged_id$Zone), ]

#group the data for plotting
dat_flagged_id <- dat_flagged_id %>%
  group_by(Site_Code) %>%
  mutate(row_num = factor(row_number())) %>%  # create row_num as factor per group
  #mutate(sample_name = factor(sample_name, 
                             # levels = sample_name[order(Zone)])) %>%  # create row_num as factor per group
   mutate(sample_name = factor(sample_name, 
                              levels = unique(sample_name[order(Zone)]))) %>%
  ungroup()

#Plot data and change colors based on flags to check it: 
viz_c_plot <- ggplot(dat_flagged_id, aes(x = sample_name, y = ic_raw, fill = Zone)) +
  geom_bar(stat = "identity", position = position_dodge2(preserve = "single")) +
  facet_grid(~ Site_Code, scales="free_x") +
  scale_fill_manual(values = c(
    "UP" = "#20063B",
    "TR" = "#FFBC42",
    "SWAMP" = "darkgrey",
    "WC" = "#419973",
    "SW" = "#25ABE6"
  )) +
  theme_classic() +
  labs(x = " ", y = "IC (mg/L)", title = "Samples: DIC") +
  theme(legend.position = "none") +
  scale_x_discrete(drop = TRUE) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))


print(viz_c_plot)


```

## Convert data from mg/L to uMoles/L 
```{r, Unit Conversion, include=FALSE}

#convert npoc and tdn from mg/L to uMoles/L 
dat_flagged_id <- dat_flagged_id %>%
  mutate(
    ic_uM = (((as.numeric(dat_flagged_id$ic_raw))/Con1)/mw_c)*Con2
  )

```


## Check to see if samples run match metadata & merge info
```{r, check sample ids with metadata, echo=FALSE}

cat("Check Sample IDs with Metadata")

#remove duplicates from the sample dataframe bc we are just taking the first dup run
all_data_flagged <- dat_flagged_id %>%
  filter(!str_detect(sample_name, "dup")) %>%
  select(!Excess_Info)

#check to see if all samples are present in the metadata 
all_present <- all(all_data_flagged$sample_name %in% dic_metadata$DIC_ID)

if (all_present) {
  message("All sample IDs are present in metadata.")
} else {
  message("Some sample IDs are missing from metadata.")
  
  # Optional: Which ones are missing?
  missing_ids <- setdiff(all_data_flagged$sample_name, dic_metadata$DIC_ID)
  print(missing_ids)
}

dic_metadata_selected <- dic_metadata %>%
  select(DIC_ID, Year, Month, Day, Depth_cm, Lysimeter, Time..24hr., Time.Zone_EDT.EST,  Field.Notes) 

#merge metadata with sample run data 
merged_data <- all_data_flagged %>%
  left_join(dic_metadata_selected, by = c("sample_name" = "DIC_ID"))

```

## Export Processed Data  
```{r, Export Processed Data, echo=FALSE}

cat("Export Processed Data")

#Prepare data to be exported - if there is anything else to add 
#Add any necessary identifiers to the samples  ### VERY IMPORTANT AND STANDARD FOR PROJECT ####
  #example read in sample IDs list and merge 
  #create required ID columns in R, etc. 
final_data <- merged_data %>% 
  select(!row_num) %>%
  mutate(
    Project = "COMPASS: Synoptic",   # new column with same value on every row
    Region = "CB",
    Run_notes = run_notes     # new column with notes about the run
  ) 

final_data <- final_data %>%
  rename(
    Site = Site_Code,
    Time = Time..24hr., 
    Time_Zone = Time.Zone_EDT.EST,
    Replicate = Lysimeter.y,
    ic_mgL = ic_raw, 
    Sample_ID = sample_name,
    Analysis_runtime = run_datetime, 
    Field_notes = Field.Notes
    # add more rename pairs as needed
  ) %>%
  select(
    Project, Region, Site, Zone, Replicate, Depth_cm, Sample_ID, Year, Month, Day, 
    Time, Time_Zone, ic_mgL, ic_uM, ic_flag, Analysis_runtime,
    Run_notes, Field_notes, 
    # list columns in the order you want them
  )

head(final_data)

#will put final data in processed data folder 
#Write out data frame 
  write.csv(final_data, processed_file_name)

```


#end


